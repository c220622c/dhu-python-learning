# 为什么dict_item返回的字符串会带有前缀？
这一段函数的实现使用c语言编写，可以查阅源代码 https://github.com/python/cpython/blob/main/Objects/dictobject.c 的6084行左右
```c
static PyObject *
 dictview_repr(PyObject *self)
 {
     _PyDictViewObject *dv = (_PyDictViewObject *)self;
     PyObject *seq;
     PyObject *result = NULL;
     Py_ssize_t rc;
 
     rc = Py_ReprEnter((PyObject *)dv);
     if (rc != 0) {
         return rc > 0 ? PyUnicode_FromString("...") : NULL;
     }
     seq = PySequence_List((PyObject *)dv);
     if (seq == NULL) {
         goto Done;
     }
     result = PyUnicode_FromFormat("%s(%R)", Py_TYPE(dv)->tp_name, seq);
     Py_DECREF(seq);
 
 Done:
     Py_ReprLeave((PyObject *)dv);
     return result;
 }
```
可以发现，dictview_repr() 先把视图转成临时列表 seq，再用 PyUnicode_FromFormat("%s(%R)", ...) 生成最终字符串，其中 %s 是类型名、%R 是列表内容。
dict.items() 实际调用 dict_items_impl()，它通过 _PyDictView_New 创建 _PyDictViewObject，类型指针设为 PyDictItems_Type。
PyDictItems_Type.tp_repr 指向前面的 dictview_repr，所以打印时前缀固定。
# 为什么这样做？
这是一个动态视图对象，视图对象就像一个实时窗口，它时刻反映着原始字典的变化。如果你修改了字典，这个视图会立刻更新。而列表（list）则是一个静态的副本，一旦创建，就不会再随原字典改变。视图对象不会像列表那样把所有元素复制一遍存到新的内存里。它只是提供一个指向字典内部数据的“接口”或“窗口”。对于一个有数百万个条目的巨大字典来说，这能节省大量内存，且创建视图几乎是瞬时的，因为它不需要遍历和复制所有元素。
